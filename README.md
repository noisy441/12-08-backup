# Домашнее задание к занятию «Резервное копирование баз данных» - Дудин Сергей Васильевич

**Домашнее задание выполните в Google Docs или в md-файле в вашем репозитории GitHub.** 

Для оформления вашего решения в GitHub можете воспользоваться [шаблоном](https://github.com/netology-code/sys-pattern-homework).

Название файла должно содержать номер лекции и фамилию студента. Пример названия: «12.8. Резервное копирование баз данных — Александр Александров».

Перед тем как выслать ссылку, убедитесь, что её содержимое не является приватным, то есть открыто на просмотр всем, у кого есть ссылка. Если необходимо прикрепить дополнительные ссылки, просто добавьте их в свой Google Docs.

Любые вопросы по решению задач задавайте в чате учебной группы.

---

### Задание 1. Резервное копирование

### Кейс
Финансовая компания решила увеличить надёжность работы баз данных и их резервного копирования. 

Необходимо описать, какие варианты резервного копирования подходят в случаях: 

1.1. Необходимо восстанавливать данные в полном объёме за предыдущий день.

1.2. Необходимо восстанавливать данные за час до предполагаемой поломки.

1.3.* Возможен ли кейс, когда при поломке базы происходило моментальное переключение на работающую или починенную базу данных.

*Приведите ответ в свободной форме.*

---

### Решение 1.

1.1 Нужно восстановить данные полностью за предыдущий день. Для этой цели подойдет ежедневный полный (горячий) или еженедельный полный + ежедневный дифференциальный бекап. При таком подходе, мы например, ночью в одно и то же время делаем полный бекап и храним их неколько дней, в зависимости от того, как мы решили в оргпнизации. В идеале храмин в разнвх местах, чтобы минимизировать риски связанные с провайдером услуг. Мы легко сможем восстановить копию базы на любую дату из тех, которые хранятся у нас в хранилище бекапов, но при этом копии занимают дисковое пространство.

1.2 Нужно восстановить данные за час до предполагаемой поломки. Будем делать ежедневный полный (горячий) бекап и непрерывно архивировать журнал транзакций (transaction log). Если нам понадобится восстановить состояние базы за час до прежполагаемой поломки, мы восстанавливаем основной бекам за предыдущие сути и поверх накатываем транзакции до необходимого времени.
*В качестве альтернативы можно рассмотреть возможность почасового снятия snapshot’ов томов/дисков*

1.3 Да, это возможно, но это уже не будет бекап, а скорее отказоустойчивый кластер СУДБ. Для этого БД должна быть размещена у провйдера облачных услуг (например Яндекс cloud). При таком подходе, у нас присутствует Primary + синхронная (или ассинхронная) реплика (RPO ≈ 0) и автоматический failover. В зависимости от того, синхронная или ассинхронная реплика используется будет отличаться RPO. В случае с ассинхронной перликой он может достигать десятков секунд. 
При возникновении проблем или поломки базы, failover автоматически моментально переключит запросы на работающую БД, а в случае возвращения в строй починенной баззы, плановый switchover/role change позволит переключить запросы обратно, либо вручную либо по расписанию. 

---

### Задание 2. PostgreSQL

2.1. С помощью официальной документации приведите пример команды резервирования данных и восстановления БД (pgdump/pgrestore).

2.1.* Возможно ли автоматизировать этот процесс? Если да, то как?

*Приведите ответ в свободной форме.*

---

### Решение 2.

2.1 Пример команды резервирования данных и восстановления БД. Дополнительные флаги позволят более качественно и быстро восстановить базу. Например удалять имеющиеся значения перед восстановлением (--clean) и использовать парралельное восстановление (-j).
- Резервное копирование:
  - ```pg_dump -h db.example.com -U backup_user -F c -f /backups/mydb.dump mydb```
 
- Восстановление:
  - ```createdb -h db.example.com -U postgres mydb_restored```
  - ```pg_restore -h db.example.com -U postgres -d mydb_restored --clean --if-exists -j 4 /backups/mydb.dump```

2.2 Да, процесс можно автоматизировать, например с помощью cron и shell-скрипта. 

- ~/.pgpass для безопасной аутентификации:
  - ```echo "db.example.com:5432:mydb:backup_user:SuperSecret" >> ~/.pgpass```
  - ```chmod 600 ~/.pgpass```
    
Скрипт /usr/local/bin/pgdump_daily.sh:

```
#!/usr/bin/env bash
set -euo pipefail
DB_HOST="db.example.com"
DB_NAME="mydb"
DB_USER="backup_user"
OUT_DIR="/var/backups/postgres"
TS=$(date +%F_%H%M%S)
mkdir -p "$OUT_DIR"
FILE="$OUT_DIR/${DB_NAME}_${TS}.dump"
pg_dump -h "$DB_HOST" -U "$DB_USER" -F c -f "$FILE" "$DB_NAME"
find "$OUT_DIR" -name "${DB_NAME}_*.dump" -mtime +14 -delete
```
В планировщике cron добавим строку

```
0 2 * * * /usr/local/bin/pgdump_daily.sh >> /var/log/pgdump_daily.log 2>&1
```

Таким образом, планировщик будет запускать скрипт в 2 часа ночи ежедневно, и после создания бекапа будет осуществлять проверку количеества удаляя все бекапы старше 14 дней.

---

### Задание 3. MySQL

3.1. С помощью официальной документации приведите пример команды инкрементного резервного копирования базы данных MySQL. 

3.1.* В каких случаях использование реплики будет давать преимущество по сравнению с обычным резервным копированием?

*Приведите ответ в свободной форме.*

---

### Решение 3.

3.1 Создание инкрементного резервного копировния в mysql осуществляется на базе полного бекапа, поэтому, в команде я буду использовать ссылку на полный бекап.
Перед началом, обязательно нужно сделать полный бэкап, а потом выполнить:

```
mysqlbackup --defaults-file=/home/dbadmin/my.cnf \
  --incremental --incremental-base=history:last_backup \
  --backup-dir=/home/dbadmin/temp_dir \
  --backup-image=incremental_image1.bi \
   backup-to-image

```

Я использую ```--incremental-base=history:last_backup``` Этот параметр указывает MySQL Enterprise Backup использовать последний успешный бэкап в качестве основы для инкрементального бэкапа. Mysqlbackup извлекает LSN последней успешной (не TTS) полной или частичной резервной копии из таблицы mysql.backup_history и на основе этих данных выполняет инкрементное резервное копирование.

3.1.*  Когда реплика даёт преимущество по сравнению с «обычным» бэкапом:

- Низкий RTO и высокая доступность: при падении мастера можно быстро использовать реплику (минуты/секунды), вместо долгого восстановления из бэкапа.
- Снижение нагрузки: бэкапы (mysqldump/mysqlbackup), отчетные запросы и ETL выполняются с реплики, не затрагивая primary.
- Гео‑резерв: реплика в другом ЦОД/регионе, быстрая смена роли при аварии в ЦОД.
- Обновления с минимальным простоем: все обновления и справления можно применять на репликах во время обслуживания.
- Защита от логических ошибок: задержанная реплика (delayed replica) позволяет «отрезать» ошибочные изменения до их применения.
- Масштабирование чтения: реплики обслуживают read‑нагрузку, основной узел сосредоточен на записи.
  
Важно не забывать, что реплика — не замена бэкапам. Нужно применять и реплики и бекапы.
---

Задания, помеченные звёздочкой, — дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже шире разобраться в материале.
